<?php
 namespace MailPoetVendor\Doctrine\ORM\Tools\Pagination; if (!defined('ABSPATH')) exit; use MailPoetVendor\Doctrine\DBAL\Platforms\DB2Platform; use MailPoetVendor\Doctrine\DBAL\Platforms\OraclePlatform; use MailPoetVendor\Doctrine\DBAL\Platforms\PostgreSqlPlatform; use MailPoetVendor\Doctrine\DBAL\Platforms\SQLAnywherePlatform; use MailPoetVendor\Doctrine\DBAL\Platforms\SQLServerPlatform; use MailPoetVendor\Doctrine\ORM\Query\AST\OrderByClause; use MailPoetVendor\Doctrine\ORM\Query\AST\PartialObjectExpression; use MailPoetVendor\Doctrine\ORM\Query\AST\SelectExpression; use MailPoetVendor\Doctrine\ORM\Query\SqlWalker; use MailPoetVendor\Doctrine\ORM\Query\AST\SelectStatement; class LimitSubqueryOutputWalker extends \MailPoetVendor\Doctrine\ORM\Query\SqlWalker { private const ORDER_BY_PATH_EXPRESSION = '/(?<![a-z0-9_])%s\\.%s(?![a-z0-9_])/i'; private $platform; private $rsm; private $queryComponents; private $firstResult; private $maxResults; private $em; private $quoteStrategy; private $orderByPathExpressions = []; private $inSubSelect = \false; public function __construct($query, $parserResult, array $queryComponents) { $this->platform = $query->getEntityManager()->getConnection()->getDatabasePlatform(); $this->rsm = $parserResult->getResultSetMapping(); $this->queryComponents = $queryComponents; $this->firstResult = $query->getFirstResult(); $this->maxResults = $query->getMaxResults(); $query->setFirstResult(null)->setMaxResults(null); $this->em = $query->getEntityManager(); $this->quoteStrategy = $this->em->getConfiguration()->getQuoteStrategy(); parent::__construct($query, $parserResult, $queryComponents); } private function platformSupportsRowNumber() { return $this->platform instanceof \MailPoetVendor\Doctrine\DBAL\Platforms\PostgreSqlPlatform || $this->platform instanceof \MailPoetVendor\Doctrine\DBAL\Platforms\SQLServerPlatform || $this->platform instanceof \MailPoetVendor\Doctrine\DBAL\Platforms\OraclePlatform || $this->platform instanceof \MailPoetVendor\Doctrine\DBAL\Platforms\SQLAnywherePlatform || $this->platform instanceof \MailPoetVendor\Doctrine\DBAL\Platforms\DB2Platform || \method_exists($this->platform, 'supportsRowNumberFunction') && $this->platform->supportsRowNumberFunction(); } private function rebuildOrderByForRowNumber(\MailPoetVendor\Doctrine\ORM\Query\AST\SelectStatement $AST) { $orderByClause = $AST->orderByClause; $selectAliasToExpressionMap = []; foreach ($AST->selectClause->selectExpressions as $selectExpression) { $selectAliasToExpressionMap[$selectExpression->fieldIdentificationVariable] = $selectExpression->expression; } foreach ($orderByClause->orderByItems as $orderByItem) { if (\is_string($orderByItem->expression) && isset($selectAliasToExpressionMap[$orderByItem->expression])) { $orderByItem->expression = $selectAliasToExpressionMap[$orderByItem->expression]; } } $func = new \MailPoetVendor\Doctrine\ORM\Tools\Pagination\RowNumberOverFunction('dctrn_rownum'); $func->orderByClause = $AST->orderByClause; $AST->selectClause->selectExpressions[] = new \MailPoetVendor\Doctrine\ORM\Query\AST\SelectExpression($func, 'dctrn_rownum', \true); $AST->orderByClause = null; } public function walkSelectStatement(\MailPoetVendor\Doctrine\ORM\Query\AST\SelectStatement $AST) { if ($this->platformSupportsRowNumber()) { return $this->walkSelectStatementWithRowNumber($AST); } return $this->walkSelectStatementWithoutRowNumber($AST); } public function walkSelectStatementWithRowNumber(\MailPoetVendor\Doctrine\ORM\Query\AST\SelectStatement $AST) { $hasOrderBy = \false; $outerOrderBy = ' ORDER BY dctrn_minrownum ASC'; $orderGroupBy = ''; if ($AST->orderByClause instanceof \MailPoetVendor\Doctrine\ORM\Query\AST\OrderByClause) { $hasOrderBy = \true; $this->rebuildOrderByForRowNumber($AST); } $innerSql = $this->getInnerSQL($AST); $sqlIdentifier = $this->getSQLIdentifier($AST); if ($hasOrderBy) { $orderGroupBy = ' GROUP BY ' . \implode(', ', $sqlIdentifier); $sqlIdentifier[] = 'MIN(' . $this->walkResultVariable('dctrn_rownum') . ') AS dctrn_minrownum'; } $sql = \sprintf('SELECT DISTINCT %s FROM (%s) dctrn_result', \implode(', ', $sqlIdentifier), $innerSql); if ($hasOrderBy) { $sql .= $orderGroupBy . $outerOrderBy; } $sql = $this->platform->modifyLimitQuery($sql, $this->maxResults, $this->firstResult); foreach ($sqlIdentifier as $property => $alias) { $this->rsm->addScalarResult($alias, $property); } return $sql; } public function walkSelectStatementWithoutRowNumber(\MailPoetVendor\Doctrine\ORM\Query\AST\SelectStatement $AST, $addMissingItemsFromOrderByToSelect = \true) { if ($AST->orderByClause instanceof \MailPoetVendor\Doctrine\ORM\Query\AST\OrderByClause && $addMissingItemsFromOrderByToSelect) { $this->addMissingItemsFromOrderByToSelect($AST); } $orderByClause = $AST->orderByClause; $AST->orderByClause = null; $innerSql = $this->getInnerSQL($AST); $sqlIdentifier = $this->getSQLIdentifier($AST); $sql = \sprintf('SELECT DISTINCT %s FROM (%s) dctrn_result', \implode(', ', $sqlIdentifier), $innerSql); $sql = $this->preserveSqlOrdering($sqlIdentifier, $innerSql, $sql, $orderByClause); $sql = $this->platform->modifyLimitQuery($sql, $this->maxResults, $this->firstResult); foreach ($sqlIdentifier as $property => $alias) { $this->rsm->addScalarResult($alias, $property); } $AST->orderByClause = $orderByClause; return $sql; } private function addMissingItemsFromOrderByToSelect(\MailPoetVendor\Doctrine\ORM\Query\AST\SelectStatement $AST) { $this->orderByPathExpressions = []; $walker = clone $this; $walker->walkSelectStatementWithoutRowNumber($AST, \false); $orderByPathExpressions = $walker->getOrderByPathExpressions(); $selects = []; foreach ($orderByPathExpressions as $pathExpression) { $idVar = $pathExpression->identificationVariable; $field = $pathExpression->field; if (!isset($selects[$idVar])) { $selects[$idVar] = []; } $selects[$idVar][$field] = \true; } foreach ($AST->selectClause->selectExpressions as $selectExpression) { if ($selectExpression instanceof \MailPoetVendor\Doctrine\ORM\Query\AST\SelectExpression) { $idVar = $selectExpression->expression; if (!\is_string($idVar)) { continue; } $field = $selectExpression->fieldIdentificationVariable; if ($field === null) { unset($selects[$idVar]); } else { unset($selects[$idVar][$field]); } } } foreach ($selects as $idVar => $fields) { $AST->selectClause->selectExpressions[] = new \MailPoetVendor\Doctrine\ORM\Query\AST\SelectExpression(new \MailPoetVendor\Doctrine\ORM\Query\AST\PartialObjectExpression($idVar, \array_keys($fields)), null, \true); } } private function preserveSqlOrdering(array $sqlIdentifier, string $innerSql, string $sql, ?\MailPoetVendor\Doctrine\ORM\Query\AST\OrderByClause $orderByClause) : string { if (!$orderByClause) { return $sql; } return \sprintf('SELECT DISTINCT %s FROM (%s) dctrn_result', \implode(', ', $sqlIdentifier), $this->recreateInnerSql($orderByClause, $sqlIdentifier, $innerSql)); } private function recreateInnerSql(\MailPoetVendor\Doctrine\ORM\Query\AST\OrderByClause $orderByClause, array $identifiers, string $innerSql) : string { [$searchPatterns, $replacements] = $this->generateSqlAliasReplacements(); $orderByItems = []; foreach ($orderByClause->orderByItems as $orderByItem) { $orderByItemString = \preg_replace($searchPatterns, $replacements, $this->walkOrderByItem($orderByItem)); $orderByItems[] = $orderByItemString; $identifier = \substr($orderByItemString, 0, \strrpos($orderByItemString, ' ')); if (!\in_array($identifier, $identifiers, \true)) { $identifiers[] = $identifier; } } return $sql = \sprintf('SELECT DISTINCT %s FROM (%s) dctrn_result_inner ORDER BY %s', \implode(', ', $identifiers), $innerSql, \implode(', ', $orderByItems)); } private function generateSqlAliasReplacements() : array { $aliasMap = $searchPatterns = $replacements = $metadataList = []; foreach (\array_keys($this->rsm->aliasMap) as $dqlAlias) { $metadataList[$dqlAlias] = $class = $this->queryComponents[$dqlAlias]['metadata']; $aliasMap[$dqlAlias] = $this->getSQLTableAlias($class->getTableName(), $dqlAlias); } foreach ($this->rsm->fieldMappings as $fieldAlias => $fieldName) { $dqlAliasForFieldAlias = $this->rsm->columnOwnerMap[$fieldAlias]; $class = $metadataList[$dqlAliasForFieldAlias]; if (!isset($class->fieldMappings[$fieldName])) { continue; } $fieldMapping = $class->fieldMappings[$fieldName]; $columnName = $this->quoteStrategy->getColumnName($fieldName, $metadataList[$dqlAliasForFieldAlias], $this->em->getConnection()->getDatabasePlatform()); $sqlTableAliasForFieldAlias = $aliasMap[$dqlAliasForFieldAlias]; if (isset($fieldMapping['declared']) && $fieldMapping['declared'] !== $class->name) { $otherClassMetadata = $this->em->getClassMetadata($fieldMapping['declared']); if (!$otherClassMetadata->isMappedSuperclass) { $sqlTableAliasForFieldAlias = $this->getSQLTableAlias($otherClassMetadata->getTableName(), $dqlAliasForFieldAlias); } } $searchPatterns[] = \sprintf(self::ORDER_BY_PATH_EXPRESSION, $sqlTableAliasForFieldAlias, $columnName); $replacements[] = $fieldAlias; } return [$searchPatterns, $replacements]; } public function getOrderByPathExpressions() { return $this->orderByPathExpressions; } private function getInnerSQL(\MailPoetVendor\Doctrine\ORM\Query\AST\SelectStatement $AST) { $hiddens = []; foreach ($AST->selectClause->selectExpressions as $idx => $expr) { $hiddens[$idx] = $expr->hiddenAliasResultVariable; $expr->hiddenAliasResultVariable = \false; } $innerSql = parent::walkSelectStatement($AST); foreach ($AST->selectClause->selectExpressions as $idx => $expr) { $expr->hiddenAliasResultVariable = $hiddens[$idx]; } return $innerSql; } private function getSQLIdentifier(\MailPoetVendor\Doctrine\ORM\Query\AST\SelectStatement $AST) { $from = $AST->fromClause->identificationVariableDeclarations; if (\count($from) !== 1) { throw new \RuntimeException('Cannot count query which selects two FROM components, cannot make distinction'); } $fromRoot = \reset($from); $rootAlias = $fromRoot->rangeVariableDeclaration->aliasIdentificationVariable; $rootClass = $this->queryComponents[$rootAlias]['metadata']; $rootIdentifier = $rootClass->identifier; $sqlIdentifier = []; foreach ($rootIdentifier as $property) { if (isset($rootClass->fieldMappings[$property])) { foreach (\array_keys($this->rsm->fieldMappings, $property) as $alias) { if ($this->rsm->columnOwnerMap[$alias] == $rootAlias) { $sqlIdentifier[$property] = $alias; } } } if (isset($rootClass->associationMappings[$property])) { $joinColumn = $rootClass->associationMappings[$property]['joinColumns'][0]['name']; foreach (\array_keys($this->rsm->metaMappings, $joinColumn) as $alias) { if ($this->rsm->columnOwnerMap[$alias] == $rootAlias) { $sqlIdentifier[$property] = $alias; } } } } if (\count($sqlIdentifier) === 0) { throw new \RuntimeException('The Paginator does not support Queries which only yield ScalarResults.'); } if (\count($rootIdentifier) != \count($sqlIdentifier)) { throw new \RuntimeException(\sprintf('Not all identifier properties can be found in the ResultSetMapping: %s', \implode(', ', \array_diff($rootIdentifier, \array_keys($sqlIdentifier))))); } return $sqlIdentifier; } public function walkPathExpression($pathExpr) { if (!$this->inSubSelect && !$this->platformSupportsRowNumber() && !\in_array($pathExpr, $this->orderByPathExpressions)) { $this->orderByPathExpressions[] = $pathExpr; } return parent::walkPathExpression($pathExpr); } public function walkSubSelect($subselect) { $this->inSubSelect = \true; $sql = parent::walkSubselect($subselect); $this->inSubSelect = \false; return $sql; } } 